\chapter{Das Programm}\label{the_program}

Wir wollen nun auf eine Implementierung des Algorithmus aus dem vorherigen Abschnitt eingehen. Der Code wurde in SageMath \cite{sage} geschrieben und ist auf Anfrage erhältlich. Das Multi-Fluss-Problem auf $\mathcal{N}_G$ zu gegebenen Bedarfen $(d_1,d_2)$ wird hier, mithilfe des in Sage enthaltenen Solvers \textit{Glpk} \cite{glpk} für Lineare Programmierung gelöst, welcher ein Paar von Flussgraphen $(\varphi_1,\varphi_2)$ ausgibt, falls eine zulässige Lösung existiert und sonst nichts.

\input{pseudocode1.tex}

Aus einer ganzzahligen Lösung kann man ein Gutes-FAA $\phi$ aus $\varphi_2$ extrahieren indem man die Zuweisungs-Pfade durch die Dummy-Senke zurück verfolgt. Wir betreten jeden passierten Dummy-Knoten $v^*$ aus einem Winkel $(f,v)$. Diese Winkel ergeben die Zuweisungen $\phi$.

\section{Dokumentation}

TODO

\begin{itemize}
\item Die Kontrolle, ob für $G$ ein FAA existiert ist optional, lässt sich jedoch, zum Beispiel wie zuvor über ein 1-Fluss-Problem, in polynomineller Zeit bestimmen. Somit spart sie im Falle, der nicht Existenz eines FAA Zeit. 
\item Bei der Inizialisierung von $\mathcal{N}_G$ wird das innere Netzwerk in Gebieten $f$ mit $|f|=3$ weggelassen, da in jeder zulässigen Lösung der Fluss aus den Ecken die kleinen Quadrate voll ausfüllt. Der Bedarf muss dementsprechend angepasst werden.
\item  Optional 
\end{itemize}

\section{Visualisierung}

Nehmen wir an, wir haben für einen Graphen $G$ ein Gutes-FAA $\phi$ gefunden. Für eine SLTR, müssen wir eine zu $\phi$ passende Einbettung von $G$ finden. Wir werden den in Abschnitt \ref{harmonic_approach} erörterten Ansatz über harmonische Funktionen nutzen, um eine SLTR von $G$ zu erhalten.

Wir wollen nun eine Einbettung $f:V\to \mathbb{R}^2$ von $G$ ähnlich der Gummibad-Repräsentation berechnen, die $\phi$ respektiert. Sei $S \subseteq V$ die Menge der Knoten von $f_{aus}$. Nach Abschnitt \ref{harmonic_approach} gelten die folgenden harmonischen Gleichungen für zugewiesene (oben) und nicht zugewiesene (unten) Knoten.
$$ f(v) = \lambda_v f(u) + (1-\lambda_v)f(w) \text{, mit } \lambda_v \in (0,1) $$
$$ f(v) = \sum_{u \in N(v)} \lambda_{uv} f(u) \text{, mit }  \sum_{u \in N(v)}\lambda_{uv} = 1 \text{ und } \lambda_{uv} > 0 $$
Um zu einer gegebenen Gewichtsfunktion $\lambda$ eine Lösung zu finden, können wir diese Gleichungen, um die Aufhängungen $A = \{a_1,a_2,a_3\}$ erweitern und als Matrix schreiben.
\[ M_{\lambda}(\vec{v_x},\vec{v_y}) = \big( \begin{smallmatrix}f(A)_x&f(A)_y\\ 0&0\end{smallmatrix} \big) \text{, mit } (M_{\lambda})_{vw} =
	\begin{dcases}
	-\lambda_{vw} & \text{falls } (v,w) \in E, \\
	\textstyle\sum_{u \in N(v)} \lambda_{uv} & \text{falls } v = w, \\
	0 & \text{sonst.} \\
	\end{dcases}
\]
Wenn wir nun die Pseudo-Inverse (TODO) berechnen, erhalten wir die Lösung
$$f(V) = M_{\lambda}^{-1}\big( \begin{smallmatrix}f(A)_x&f(A)_y\\ 0&0\end{smallmatrix} \big).$$
Wir wollen nun, inspiriert von den \textit{iterativen Tutte Einbettungen} aus \cite{fs17}, diese Rechnung mehrmals durchführen und Schritt für Schritt die Gewichtung $\lambda$ anpassen. Wünschenswert wäre es, wenn sich die Zeichnung nach einer gewissen Anzahl an Schritten nur noch so wenig verändert, dass wir den Algorithmus abbrechen können, und die letzte Zeichnung ausgeben.

\subsection{Eine gute Wahl von $\lambda$}

Setzten wir im ersten Durchlauf $\lambda = 1$ erhalten wir eine klassische Gummiband-Repräsentation die $\phi$ respektiert. Wir wollen nun anhand dieser Einbettung $\lambda$ verändern um, Iteration für Iteration, eine \glqq schönere\grqq{ } Einbettung zu erhalten. Halten wir zwei Punkte fest, die wir intuitiv als Bewertungsmaßstab für eine schöne Einbettung berücksichtigen können.
\begin{itemize}
\item Es gibt keine zu großen oder zu kleinen Gebiete.
\item Es existieren keine zu langen oder kurzen Kanten.
\end{itemize}

Es gibt SLTRs, wie in Beispiel \ref{bsp_long_segment}, bei denen alle inneren Knoten zugewiesen sind. Dies macht eine gute Wahl der $\lambda$ kompliziert. Der Ansatz aus \cite{fs17}, bei dem $\lambda(e)$ als monoton steigende Funktion, proportional zu Größe der angrenzenden Gebiete und der Lange der Kante, gewählt wird bringt im Allgemeinen keine schönen Ergebnisse.

\begin{example}\label{bsp_long_segment}
Bei der in Abbildung \ref{exp_long_segment} SLTR sind alle Knoten bis auf die Aufhängungen einer einem Gebiet zugeordnet. Somit liegt jeder Knoten auf einer Gerade und es existieren nur Gleichungen von Typ
$$ f(v) = \lambda_v f(u) + (1-\lambda_v)f(w) \text{, mit } \lambda_v \in (0,1).$$
Intuitiv wollen wir das Gebiet unten in der Mitte verkleinern, doch die drei angrenzenden Kanten kommen in keiner der Gleichungen zu Bestimmung unserer Einbettung $f(V)$ vor. Die Kanten die uns helfen können das Segment in rot nach unten zu bewegen und somit das untere Dreieck zu verkleinern sind in blau eingefärbt. Um zur Zeichnung auf der rechten Seite zu gelangen erfolgt die Wahl der $\lambda$ nach dem folgenden Prinzip.
\begin{itemize}
\item [1.] Erstelle eine Liste $S$ aller Segmente der SLTR.
\item [2.] Bestimmte für jedes Segment die Fläche aller Gebiete deren Randknoten alle auf auf der linken und rechten Seite.
\item [3.] ... TODO
\end{itemize}
\end{example}

\begin{example}\label{bsp_large_corner} 
Gerade für Graphen mit vielen Knoten führt der Ansatz aus Beispiel \ref{bsp_long_segment} nicht immer zu einer schönen Zeichnung der SLTR. In Abbildung \ref{exp_large_corner} ist so ein Graph mit der ersten für $\lamda=1$ erhaltenen Zeichnung und dem Resultat nach 40 Schritten zu sehen. Ein anderer interaktiver Ansatz führt hier jedoch zu schöneren Ergebnissen. Wir setzen bei der Initialisierung $\lamda_0(e)=1$ für jede Kante von $G$. Nun multiplizieren wir die Kanten an den Gebieten $f$ mit $A(f) > A(f_{max})*(1+\epsilon)$ mit einer Konstante $c \in \mathbb{N}$. Für diese Kanten gilt somit $\lambda_{i+1}(e) = $\lambda_{i+1}(e)*c$. Wir wählen $\epsilon = 0,1$ und $c=2$. 

Rechts in Abbildung ist das Ergebnis nach $|V|$ Schritten zu sehen.
\end{example}

Der Ansatz aus Beispiel \ref{bsp_large_corner} führt jedoch auch bei manchen Graphen zu keiner schönen Zeichnung. Doch ein Kompromiss aus beiden hat heuristisch vielversprechende Zeichnungen erzeugt.


\section{Statistische Betrachtung}

Für eine statistische Betrachtung der Häufigkeit von Graphen mit SLTRs wurde das Programm auf pseudo-zufällige Graphen laufen lassen. Hier würde eine gleichmäßige Wahl von (intern-)3-zusammenhängenden Graphen unter Umständen andere Ergebnisse liefern. Ein uniformer Algorithmus zur zufälligen Erstellung 3-zusammenhängender planarer Graphen lässt sich zum Beispiel nach einem Ansatz von Fusy aus \cite{fusy07} erstellen. Als Teilschritt der Erstellung eines uniformen Samplers für planare Graphen werden hier 3-zusammenhängende planare Graphen mit gleichverteilter Wahrscheinlichkeit erzeugt. Die Implementierung ist jedoch aufgrund der Auswertung von Erzeugendenfunktionen, nicht trivial. Diese Analyse beschränkt sich daher auf pseudo-zufällig erzeugte Graphen. \\

In Abbildung \ref{table} sind die Ergebnisse für Graphen von vier bis TODO Knoten dargestellt, mit jeweils TODO Graphen für jede Knotenzahl. Wir übergeben dem Programm einen Graphen mit Aufhängungen $\{a_1,a_2,a_3\}$, was im Falle 3-zusammenhängender planer Graphen mit mehr als drei Knoten ein äusseres Gebiet induziert. Ein Punkt in der Abbildung entspricht einem Graphen. Die Farben stehen für eine SLTR (blau), nur ein FAA (rot) oder einen Graphen mit keinem von beiden (grün). \\

\input{table.tex}
